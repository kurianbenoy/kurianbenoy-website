---
title: Log4- Learning FastBook along with Study Group
type: post
published: true
tags: [fastbook, myself, ML, Deep learning]
cover-img: "/img/fastbookgroup.jpeg"
share-img: "/img/fastbookgroup.jpg"
readtime: true
---

## Recap of Week 4

- The topic covered for this week was Going Deeper Into Computer Vision w/ MNIST Digit Classifier
- Pixels are the foundation of images, and we are using MNIST dataset to explore Deep learning
- We are using `URLs.MNIST_SAMPLE`, which is a sample of images of 3 and 7. There is another dataset MNIST containing handwritten images `from digits 0-9`.
- In computer everything is an array
- Lot of wonderful ideas were discuss how to classify images in the [discussion thread](https://wandb.me/fastbook-4) like classifying number based “surface % of this square of background that is covered by number”.
-  We decided to go with Pixel similarity, that is to find average value for every pixels of 3s and 7s. Then the two group averages define what is the ideal 3 and ideal 7
- The first difference we are going to see, is what is the difference b/w tensor and array. Array is terminology in numpy and tensor for pythorch
- rank is the number of axes or dimensions in a tensor
- shape is the size of each axis of a tensor
- Now for our ML model, to distinguish between images of 3 and 7. What it does is basically, check if compare our mean images of 3 and 7 obtained by stacking images and finding mean. Then you compare the new image and find difference between mean of 3 and 7. As Aman pointed out, when subtracting between two unlike quantities there is a possibility to cancel out.
![image](https://user-images.githubusercontent.com/24592806/124618845-c4e88c00-de95-11eb-9ad5-932368a11078.png)
- So calculate with absolute value to find difference(L1 loss)
- Else calculate by finding difference and then sqaruing(L2 loss- rmse loss)
- Major difference b/w Pytorch and Numpy is:
a) Pytorch works on GPU and Numpy is working on CPU
b) Pytorch can automatically calculate gradients
- Computing Metrics using broadcasting. Broadcasting is automatic filling of lists to match matrix shape
- Check `mnist_distance` function which is used to do pixel similarity comparison:

{% highlight python %}

def mnist_distance(a,b):
  return (a-b).abs().mean((-1,-2))
mnist_distance(a_3, mean3)

{% endhighlight %}
- Why mean((-1, -2)) is used to find mean across width and height of image?
- Detailed explaination by Srinivas Raman in Week 4 discussion forum:
```Since the valid3_tens has a shape of (1010, 28, 28) and the ideal3 will have a shape of (1, 28, 28)
with broadcasting the ideal 3 will be broadcast over the 1st dimension. Now we want the average of the 
pixel values over the last two dimensions. The last two dimensions which are the height & width of image
are indexed by using -1 index and -2 index. In python -1 refers to the last element and in this case
the last dim of a tensor and -2 is the 2nd last dim of tensor and so refers to the 28x28 dims of 
our valid3_tens and valid_tens
```
- Then we found the accuracy of validation dataset.

> Highlights of the full session can be found by clicking the below video:

[![IMAGE ALT TEXT](http://img.youtube.com/vi/jK0yp2mPRic/0.jpg)](http://www.youtube.com/watch?v=jK0yp2mPRic "Video Title")

[Week 4 Discussion forum](https://wandb.me/fastbook-4)

### *Now let me share some of my personal learnings over the whole week*:

Snce I was interested to know more about broadcasting, I watched [Andrew NG lesson on broadcasting](https://youtu.be/tKcLaGdvabM). 
He gives an interesting problem to use broadcasting to caclulate the percentage of calories
of carbs, proteins, fats in 100 g of following food

![image](https://user-images.githubusercontent.com/24592806/124651060-1a359500-deb8-11eb-9245-2475dea2bbc7.png)

{% highlight python %}
import numpy as np

A = np.array([
[56.0, 0., 4.4, 68.0],
[1.2, 104.0, 52.0, 8.0],
[1.8, 135.0, 99.0, 0.0]
])

cal = A.sum(axis=0)

#Divide A which is a 3/4 matrix, and divide it by 1/4 matrix
# reshape is O(1) operation
100*A/cal

{% endhighlight %}

### General principle of broadcasting

![image](https://user-images.githubusercontent.com/24592806/124652523-d93e8000-deb9-11eb-9dbd-47daa4ba1025.png)


